<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture 9: Introduction to Trees</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Prism.js for code highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        /* Custom CSS for 'Inter' font and base styles from the existing site */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f3f4f6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .content-area {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 2rem;
            box-sizing: border-box;
        }

        .presentation-card {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            padding: 2.5rem;
            width: 90%;
            max-width: 960px;
            box-sizing: border-box;
        }

        .presentation-card h1, .presentation-card h2 {
            color: #1f2937;
            margin-bottom: 1.5rem;
            font-weight: 800;
        }
        
        .presentation-card h3 {
             color: #1f2937;
             font-weight: 700;
             margin-top: 1.5rem;
             margin-bottom: 1rem;
        }

        .presentation-card p, .presentation-card li {
            color: #4b5563;
            line-height: 1.7;
            margin-bottom: 1rem;
            font-size: 1.05rem;
        }
        
        .presentation-card code:not(pre > code) {
            background-color: #eef2ff;
            color: #4338ca;
            padding: 0.2rem 0.5rem;
            border-radius: 0.375rem;
            font-family: 'Courier New', Courier, monospace;
            font-weight: 600;
        }
        
        .presentation-card pre {
            border-radius: 0.5rem;
            margin-top: 1rem;
            background-color: #2d2d2d; /* Matching prism-tomorrow */
            color: #e5e7eb; /* Light text for dark background */
            padding: 1.5rem; /* Added padding for better spacing */
            overflow-x: auto; /* Ensures horizontal scroll if content is too wide */
        }

        .presentation-card .example-box {
            background-color: #f9fafb;
            border-left-width: 4px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            margin-bottom: 2.5rem;
            border-radius: 0.5rem;
        }
        
        .code-toggle-button {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            display: inline-block;
            margin-top: 1rem;
        }
        .code-toggle-button:hover {
            background-color: #4338ca;
        }
        
        .hidden-code {
            display: none;
        }

        /* Navigation Bar Styles to match site */
        .navbar {
            background-color: #4338ca;
            padding: 1rem 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .navbar a {
            color: white;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
        }

        .navbar a:hover {
            background-color: #4f46e5;
            transform: translateY(-2px);
        }

        .navbar a.active-nav {
            background-color: #6d28d9;
            font-weight: 700;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem;
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 0.75rem;
            text-align: left;
        }
        th {
            background-color: #f9fafb;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .presentation-card { padding: 1.5rem; width: 95%; }
            .presentation-card h1 { font-size: 2.2rem; }
            .presentation-card h2 { font-size: 1.8rem; }
            .navbar { justify-content: flex-start; overflow-x: auto; }
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <!-- Navigation links will be inserted here by update_nav.js -->
    </nav>
    
    <!-- Include the navigation update script -->
    <script src="update_nav.js"></script>
    
    <!-- Include the navigation update script -->
    <script src="update_nav.js"></script>
    
    <!-- Main Content Area -->
    <main class="content-area">
        <div class="presentation-card">
            <div class="text-center mb-8">
                <h1 class="text-4xl lg:text-5xl font-extrabold text-indigo-700 mb-4">Class 1: Introduction to Trees</h1>
                <p class="text-lg text-gray-600">Your first step into non-linear data structures.</p>
            </div>

            <hr class="my-12 border-t-2 border-gray-200">

            <h2 class="text-3xl font-bold text-gray-800">üå≥ Introduction to Trees</h2>
            <div class="example-box border-l-green-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">What is a Tree?</h3>
                <p>So far, you've worked with linear data structures like arrays and linked lists, where elements are arranged sequentially. A <strong>tree</strong> is different. It's a <strong>hierarchical</strong> data structure that consists of nodes connected by edges. Think of it like a family tree or an organization chart.</p>
                
                <h3 class="text-xl font-bold text-gray-800">Key Terminology</h3>
                <ul class="list-disc list-inside text-gray-600">
                    <li><strong>Node:</strong> An entity that contains a value and pointers (references) to its children.</li>
                    <li><strong>Edge:</strong> The link between two nodes.</li>
                    <li><strong>Root:</strong> The topmost node in a tree. It's the only node that doesn't have a parent.</li>
                    <li><strong>Parent:</strong> A node that has an edge to a child node.</li>
                    <li><strong>Child:</strong> A node that has a parent node.</li>
                    <li><strong>Leaf:</strong> A node that has no children. These are the "ends" of the tree.</li>
                    <li><strong>Height:</strong> The number of edges on the longest path from a node to a leaf. The height of the tree is the height of the root.</li>
                    <li><strong>Depth:</strong> The number of edges from the root to a specific node. The depth of the root is 0.</li>
                    <li><strong>Level:</strong> The level of a node is its depth + 1. The root is at Level 1.</li>
                </ul>
            </div>

            <h2 class="text-3xl font-bold text-gray-800">What is a Binary Tree?</h2>
            <div class="example-box border-l-blue-500">
                <p>A <strong>Binary Tree</strong> is a specific type of tree where every node can have at most <strong>two</strong> children: a <code>left</code> child and a <code>right</code> child. This constraint makes them particularly efficient for certain operations.</p>
                <h3 class="text-xl font-bold text-gray-800">Types of Binary Trees</h3>
                <p><strong>1. Full Binary Tree:</strong> Every node has either 0 or 2 children.</p>
                <pre><code>
      18
     /  \
    15   30
   /  \
  40   50
                </code></pre>
                <p><strong>2. Complete Binary Tree:</strong> All levels are completely filled except possibly the last level, which is filled from left to right.</p>
                 <pre><code>
      18
     /  \
    15   30
   /  \  /
  40  50 22
                </code></pre>
                <p><strong>3. Perfect Binary Tree:</strong> All internal nodes have two children, and all leaf nodes are at the same level.</p>
                 <pre><code>
      18
     /  \
    15   30
   / \   / \
  40 50 22 25
                </code></pre>
                <p><strong>4. Skewed Binary Tree:</strong> Each node is connected to only one child (all left or all right), essentially resembling a linked list.</p>
                <pre><code>
      18
     /
    15
   /
  40
 /
10
                </code></pre>
            </div>

            <hr class="my-12 border-t-2 border-gray-200">

            <h2 class="text-3xl font-bold text-gray-800">‚ùì Why & When to Use Trees?</h2>
            <div class="example-box border-l-purple-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">Motivation</h3>
                <p>Arrays are great for quick access by index (<code>O(1)</code>), but searching for a value takes <code>O(n)</code> time. Insertion and deletion are also slow (<code>O(n)</code>). Trees, especially Binary Search Trees (which we'll cover later), can offer much faster search, insertion, and deletion, often in <code>O(log n)</code> time.</p>
                <h3 class="text-xl font-bold text-gray-800">When are Trees Helpful?</h3>
                <ul class="list-disc list-inside text-gray-600">
                    <li><strong>Hierarchical Data:</strong> Perfect for representing anything with a natural parent-child relationship.</li>
                    <li><strong>Fast Access/Search:</strong> When you need to find, add, or remove elements quickly.</li>
                </ul>
                <h3 class="text-xl font-bold text-gray-800">Real-World Applications</h3>
                <ul class="list-disc list-inside text-gray-600">
                    <li><strong>File Systems:</strong> Directories and files are a natural tree structure.</li>
                    <li><strong>HTML DOM:</strong> The Document Object Model represents an HTML page as a tree of elements.</li>
                    <li><strong>Expression Trees:</strong> Used by compilers to parse and evaluate mathematical expressions.</li>
                    <li><strong>Auto-suggestions (Tries):</strong> A special kind of tree called a Trie is used for predictive text.</li>
                </ul>
            </div>

            <hr class="my-12 border-t-2 border-gray-200">
            
            <h2 class="text-3xl font-bold text-gray-800">üîÅ Basic Tree Traversals</h2>
            <p>Traversing a tree means visiting every node exactly once. Since trees aren't linear, we have different ways to do this. The main categories are Depth-First Search (DFS) and Breadth-First Search (BFS).</p>
            
            <div class="example-box border-l-red-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">Depth-First Traversals (DFS)</h3>
                <p>DFS goes as deep as possible down one path before backtracking. We'll use recursion, which is a natural fit here.</p>
                <p><strong>1. Inorder Traversal (Left, Root, Right):</strong> Visits the left subtree, then the root, then the right subtree. For a Binary Search Tree, this prints nodes in sorted order.</p>
                <p><strong>2. Preorder Traversal (Root, Left, Right):</strong> Visits the root first, then the left subtree, then the right subtree. Useful for creating a copy of a tree.</p>
                <p><strong>3. Postorder Traversal (Left, Right, Root):</strong> Visits the left subtree, then the right subtree, and finally the root. Useful for deleting nodes from a tree.</p>

                <button class="code-toggle-button">Show Traversal Code</button>
                <pre class="hidden-code"><code class="language-java">
// Definition for a binary tree node.
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

class TreeTraversal {
    // Inorder: Left -> Root -> Right
    public void inorder(TreeNode root) {
        if (root == null) return;
        inorder(root.left);
        System.out.print(root.val + " ");
        inorder(root.right);
    }

    // Preorder: Root -> Left -> Right
    public void preorder(TreeNode root) {
        if (root == null) return;
        System.out.print(root.val + " ");
        preorder(root.left);
        preorder(root.right);
    }

    // Postorder: Left -> Right -> Root
    public void postorder(TreeNode root) {
        if (root == null) return;
        postorder(root.left);
        postorder(root.right);
        System.out.print(root.val + " ");
    }

    public static void main(String[] args) {
        // Create a sample binary tree
        TreeNode root = new TreeNode(10);
        root.left = new TreeNode(5);
        root.right = new TreeNode(15);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(7);
        root.right.right = new TreeNode(18);

        TreeTraversal traversal = new TreeTraversal();

        System.out.print("Inorder traversal: ");
        traversal.inorder(root); // Expected: 3 5 7 10 15 18 
        System.out.println();

        System.out.print("Preorder traversal: ");
        traversal.preorder(root); // Expected: 10 5 3 7 15 18 
        System.out.println();

        System.out.print("Postorder traversal: ");
        traversal.postorder(root); // Expected: 3 7 5 18 15 10 
        System.out.println();
    }
}
                </code></pre>
            </div>

            <div class="example-box border-l-yellow-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">Breadth-First Traversal (BFS)</h3>
                <p><strong>Level Order Traversal:</strong> Visits nodes level by level, from left to right. This uses a Queue to keep track of nodes to visit next.</p>
                <button class="code-toggle-button">Show Level Order Code</button>
                <pre class="hidden-code"><code class="language-java">
import java.util.Queue;
import java.util.LinkedList;

class LevelOrderTraversal {
    public void levelOrder(TreeNode root) {
        if (root == null) return;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {
            TreeNode current = queue.poll();
            System.out.print(current.val + " ");

            if (current.left != null) queue.add(current.left);
            if (current.right != null) queue.add(current.right);
        }
    }

    public static void main(String[] args) {
        // Create the same sample binary tree
        TreeNode root = new TreeNode(10);
        root.left = new TreeNode(5);
        root.right = new TreeNode(15);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(7);
        root.right.right = new TreeNode(18);

        LevelOrderTraversal lot = new LevelOrderTraversal();
        System.out.print("Level Order traversal: ");
        lot.levelOrder(root); // Expected: 10 5 15 3 7 18 
        System.out.println();
    }
}
                </code></pre>
            </div>
            
            <hr class="my-12 border-t-2 border-gray-200">

            <h2 class="text-3xl font-bold text-gray-800">üí° Core Problems</h2>

            <!-- Problem 1: Count Nodes -->
            <div class="example-box border-l-teal-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">1. Count the Number of Nodes</h3>
                <p><strong>Problem:</strong> Given the root of a binary tree, return the total number of nodes in the tree.</p>
                <p><strong>Recursive Approach:</strong> The total count is <code>1</code> (for the current node) + <code>count(left subtree)</code> + <code>count(right subtree)</code>. The base case is an empty tree (null), which has 0 nodes.</p>
                <button class="code-toggle-button">Show Code</button>
                <pre class="hidden-code"><code class="language-java">
class CountNodesSolution {
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        return 1 + countNodes(root.left) + countNodes(root.right);
    }

    public static void main(String[] args) {
        // Create a sample binary tree
        TreeNode root = new TreeNode(10);
        root.left = new TreeNode(5);
        root.right = new TreeNode(15);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(7);

        CountNodesSolution solution = new CountNodesSolution();
        int totalNodes = solution.countNodes(root);
        System.out.println("Total number of nodes: " + totalNodes); // Expected: 5
    }
}
                </code></pre>
                <p class="mt-4"><strong>Practice Link:</strong> <a href="https://leetcode.com/problems/count-complete-tree-nodes/" class="text-indigo-600 hover:underline">LeetCode 222. Count Complete Tree Nodes</a> (A harder version, but the basic principle applies).</p>
            </div>

            <!-- Problem 2: Find Height -->
            <div class="example-box border-l-orange-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">2. Find the Height of a Binary Tree</h3>
                <p><strong>Problem:</strong> Given the root of a binary tree, find its height.</p>
                <p><strong>Recursive Approach:</strong> The height of a tree is <code>1</code> + the height of its tallest subtree (either left or right). The base case is an empty tree, which has a height of -1 (or 0, depending on definition - we'll use -1 for "number of edges").</p>
                <button class="code-toggle-button">Show Code</button>
                <pre class="hidden-code"><code class="language-java">
class HeightSolution {
    public int height(TreeNode root) {
        if (root == null) return -1;
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        return 1 + Math.max(leftHeight, rightHeight);
    }

    public static void main(String[] args) {
        // Create a sample binary tree
        TreeNode root = new TreeNode(10);
        root.left = new TreeNode(5);
        root.right = new TreeNode(15);
        root.left.left = new TreeNode(3);
        root.left.left.left = new TreeNode(1);

        HeightSolution solution = new HeightSolution();
        int treeHeight = solution.height(root);
        System.out.println("Height of the tree: " + treeHeight); // Expected: 3
    }
}
                </code></pre>
                <p class="mt-4"><strong>Practice Link:</strong> <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" class="text-indigo-600 hover:underline">LeetCode 104. Maximum Depth of Binary Tree</a> (Note: Depth and height are closely related).</p>
            </div>

            <!-- Problem 3: Sum of Nodes -->
            <div class="example-box border-l-cyan-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">3. Sum of All Nodes</h3>
                <p><strong>Problem:</strong> Given the root of a binary tree, calculate the sum of all node values.</p>
                <p><strong>Recursive Approach:</strong> The total sum is <code>current node's value</code> + <code>sum(left subtree)</code> + <code>sum(right subtree)</code>. The base case is an empty tree, which has a sum of 0.</p>
                <button class="code-toggle-button">Show Code</button>
                <pre class="hidden-code"><code class="language-java">
class SumNodesSolution {
    public int sumOfNodes(TreeNode root) {
        if (root == null) return 0;
        return root.val + sumOfNodes(root.left) + sumOfNodes(root.right);
    }

    public static void main(String[] args) {
        // Create a sample binary tree
        TreeNode root = new TreeNode(10);
        root.left = new TreeNode(5);
        root.right = new TreeNode(15);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(7);

        SumNodesSolution solution = new SumNodesSolution();
        int totalSum = solution.sumOfNodes(root);
        System.out.println("Sum of all nodes: " + totalSum); // Expected: 40
    }
}
                </code></pre>
                 <p class="mt-4"><strong>Practice Link:</strong> <a href="https://practice.geeksforgeeks.org/problems/sum-of-binary-tree/1" class="text-indigo-600 hover:underline">GeeksforGeeks: Sum of Binary Tree</a></p>
            </div>

            <!-- Problem 4: Print Leaf Nodes -->
            <div class="example-box border-l-pink-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">4. Print All Leaf Nodes</h3>
                <p><strong>Problem:</strong> Given the root of a binary tree, print the values of all its leaf nodes.</p>
                <p><strong>Recursive Approach:</strong> A node is a leaf if both its <code>left</code> and <code>right</code> children are <code>null</code>. We traverse the tree, and if we find a leaf, we print its value. If it's not a leaf, we continue the traversal on its non-null children.</p>
                <button class="code-toggle-button">Show Code</button>
                <pre class="hidden-code"><code class="language-java">
class PrintLeavesSolution {
    public void printLeaves(TreeNode root) {
        if (root == null) return;
        if (root.left == null && root.right == null) {
            System.out.print(root.val + " ");
        }
        printLeaves(root.left);
        printLeaves(root.right);
    }

    public static void main(String[] args) {
        // Create a sample binary tree
        TreeNode root = new TreeNode(10);
        root.left = new TreeNode(5);
        root.right = new TreeNode(15);
        root.left.left = new TreeNode(3);
        root.left.right = new TreeNode(7);
        root.right.left = new TreeNode(12);
        root.right.right = new TreeNode(18);

        PrintLeavesSolution solution = new PrintLeavesSolution();
        System.out.print("Leaf nodes: ");
        solution.printLeaves(root); // Expected: 3 7 12 18 
        System.out.println();
    }
}
                </code></pre>
                <p class="mt-4"><strong>Practice Link:</strong> <a href="https://practice.geeksforgeeks.org/problems/print-leaf-nodes-from-preorder-traversal-of-bst/1" class="text-indigo-600 hover:underline">GeeksforGeeks: Print leaf nodes</a></p>
            </div>

        </div>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // JavaScript to handle the "Show/Hide Code" functionality
        document.addEventListener('DOMContentLoaded', () => {
            const buttons = document.querySelectorAll('.code-toggle-button');
            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    const codeBlock = button.nextElementSibling;
                    if (codeBlock.classList.contains('hidden-code')) {
                        codeBlock.classList.remove('hidden-code');
                        button.textContent = 'Hide Code';
                    } else {
                        codeBlock.classList.add('hidden-code');
                        button.textContent = 'Show Code';
                    }
                });
            });
        });
    </script>
</body>
</html>
