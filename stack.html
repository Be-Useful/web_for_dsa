<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture 8: Stacks</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Prism.js for code highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        /* Custom CSS for 'Inter' font and base styles from existing site */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f3f4f6;
            min-height: 100vh;
            display: flex;
            flex-direction: column; 
        }

        .content-area {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 2rem;
            box-sizing: border-box;
        }

        .presentation-card {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            padding: 2.5rem;
            width: 90%;
            max-width: 960px;
            box-sizing: border-box;
        }

        .presentation-card h1, .presentation-card h2 {
            color: #1f2937;
            margin-bottom: 1.5rem;
            font-weight: 800;
        }
        
        .presentation-card h3 {
             color: #1f2937;
             font-weight: 700;
             margin-top: 1.5rem;
             margin-bottom: 1rem;
        }

        .presentation-card p, .presentation-card li {
            color: #4b5563;
            line-height: 1.7;
            margin-bottom: 1rem;
            font-size: 1.05rem;
        }
        
        .presentation-card code:not(pre > code) {
            background-color: #eef2ff;
            color: #4338ca;
            padding: 0.2rem 0.5rem;
            border-radius: 0.375rem;
            font-family: 'Courier New', Courier, monospace;
            font-weight: 600;
        }
        
        .presentation-card pre {
            border-radius: 0.5rem;
            margin-top: 1rem;
        }

        .presentation-card .example-box {
            background-color: #f9fafb;
            border-left-width: 4px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            margin-bottom: 2.5rem;
            border-radius: 0.5rem;
        }
        
        .presentation-card .complexity-tag {
            display: inline-block;
            background-color: #eef2ff;
            color: #4338ca;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-weight: 600;
            font-size: 0.9rem;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }

        /* Navigation Bar Styles to match site */
        .navbar {
            background-color: #4338ca;
            padding: 1rem 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .navbar a {
            color: white;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
        }

        .navbar a:hover {
            background-color: #4f46e5;
            transform: translateY(-2px);
        }

        .navbar a.active-nav {
            background-color: #6d28d9;
            font-weight: 700;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .interactive-button {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-right: 0.5rem;
        }
        .interactive-button:hover {
            background-color: #4338ca;
        }
        .dry-run-output {
            background-color: #eef2ff;
            border: 1px solid #c7d2fe;
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 0.5rem;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
        }

        @media (max-width: 768px) {
            .presentation-card { padding: 1.5rem; width: 95%; }
            .presentation-card h1 { font-size: 2.2rem; }
            .presentation-card h2 { font-size: 1.8rem; }
            .navbar { justify-content: flex-start; overflow-x: auto; }
        }
    </style>
</head>
<body>

    <nav class="navbar">
        <!-- Navigation links will be inserted here by update_nav.js -->
    </nav>
    
    <!-- Include the navigation update script -->
    <script src="update_nav.js"></script>
    
    <!-- Include the navigation update script -->
    <script src="update_nav.js"></script>

<!-- Main Content Area -->
<main class="content-area">
    <div class="presentation-card">
        <div class="text-center mb-8">
            <h1 class="text-4xl lg:text-5xl font-extrabold text-indigo-700 mb-4">Understanding Stacks</h1>
            <p class="text-lg text-gray-600">A fundamental data structure for managing data with LIFO principle.</p>
        </div>

        <hr class="my-12 border-t-2 border-gray-200">
        
        <!-- Stack Introduction -->
        <h2 class="text-3xl font-bold text-gray-800">1. Introduction to Stacks</h2>
        <div class="example-box border-l-blue-500">
            <h3 class="text-xl font-bold text-gray-800 mt-0">What is a Stack?</h3>
            <p>A Stack is a linear data structure that follows a particular order in which the operations are performed. The order is <strong>LIFO (Last-In, First-Out)</strong>. It is named a "stack" because it behaves like a real-world stack, for example, a stack of plates.</p>
            <p><strong>Analogy:</strong> Imagine you have a stack of plates. You can only add a new plate to the top, and you can only remove the top plate. The plate you added last is the first one you can take off. This is exactly how a stack works.</p>
            <p>Key operations are <code>push</code> (add an item to the top) and <code>pop</code> (remove the item from the top).</p>
        </div>

        <!-- Stack Operations -->
        <h2 class="text-3xl font-bold text-gray-800">2. Core Stack Operations</h2>
        <div class="example-box border-l-orange-500">
            <h3 class="text-xl font-bold text-gray-800 mt-0">Functions and Their Purpose</h3>
            <ul>
                <li><strong>push(element):</strong> Adds an element to the top of the stack. If the stack is full, it results in an "Overflow" condition.</li>
                <li><strong>pop():</strong> Removes the top element from the stack and returns it. If the stack is empty, it results in an "Underflow" condition.</li>
                <li><strong>peek() or top():</strong> Returns the top element of the stack without removing it.</li>
                <li><strong>isEmpty():</strong> Returns <code>true</code> if the stack is empty, <code>false</code> otherwise.</li>
                <li><strong>isFull():</strong> Returns <code>true</code> if the stack is full, <code>false</code> otherwise. (Mainly relevant for array-based implementations with a fixed size).</li>
            </ul>
             <div><span class="complexity-tag">Time for all operations: O(1)</span></div>
        </div>

        <!-- Implementing a Stack -->
        <h2 class="text-3xl font-bold text-gray-800">3. Implementing a Stack (from Scratch)</h2>
        <div class="example-box border-l-green-500">
            <h3 class="text-xl font-bold text-gray-800 mt-0">Array-based Implementation</h3>
            <p>Hereâ€™s how you can build a Stack using a simple array in Java. We need a variable <code>top</code> to keep track of the last inserted element.</p>
            
            <button class="interactive-button" onclick="toggleCode('stack-impl')">Show Code</button>
            <pre id="stack-impl" style="display:none;"><code class="language-java">class MyStack {
    private int arr[];
    private int top;
    private int capacity;

    // Constructor to initialize stack
    MyStack(int size) {
        arr = new int[size];
        capacity = size;
        top = -1; // Stack is initially empty
    }

    // Add an element to the stack
    public void push(int x) {
        if (isFull()) {
            System.out.println("Overflow! Stack is full.");
            return;
        }
        System.out.println("Pushing " + x);
        arr[++top] = x;
    }

    // Remove an element from the stack
    public int pop() {
        if (isEmpty()) {
            System.out.println("Underflow! Stack is empty.");
            return -1; // Or throw an exception
        }
        System.out.println("Popping " + arr[top]);
        return arr[top--];
    }

    // Return the top element of the stack
    public int peek() {
        if (isEmpty()) {
            System.out.println("Stack is empty.");
            return -1;
        }
        return arr[top];
    }

    // Check if the stack is empty
    public boolean isEmpty() {
        return top == -1;
    }

    // Check if the stack is full
    public boolean isFull() {
        return top == capacity - 1;
    }
}</code></pre>
            <button class="interactive-button" onclick="dryRunStack()">Dry Run</button>
            <div id="stack-dry-run" class="dry-run-output" style="display:none;"></div>
        </div>
        
        <!-- Stacks using inbuilt libraries -->
        <h2 class="text-3xl font-bold text-gray-800">4. Stacks using Inbuilt Libraries</h2>
        <div class="example-box border-l-purple-500">
            <h3 class="text-xl font-bold text-gray-800 mt-0">Using Java's `Stack` Class</h3>
            <p>Java provides a built-in <code>Stack</code> class in the <code>java.util</code> package, which saves you from implementing it from scratch.</p>
            <button class="interactive-button" onclick="toggleCode('stack-lib')">Show Code</button>
            <pre id="stack-lib" style="display:none;"><code class="language-java">import java.util.Stack;

class StackExample {
    public static void main(String[] args) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

        // Pushing elements
        stack.push(10);
        stack.push(20);
        stack.push(30);

        System.out.println("Current Stack: " + stack); // [10, 20, 30]

        // Peeking
        System.out.println("Top element is: " + stack.peek()); // 30

        // Popping
        System.out.println("Popped element: " + stack.pop()); // 30
        System.out.println("Popped element: " + stack.pop()); // 20

        System.out.println("Current Stack: " + stack); // [10]
        
        // Check if empty
        System.out.println("Is stack empty? " + stack.isEmpty()); // false
    }
}</code></pre>
        </div>

        <!-- Valid Parenthesis Problem -->
        <h2 class="text-3xl font-bold text-gray-800">5. Problem: Valid Parentheses</h2>
        <div class="example-box border-l-cyan-500">
            <h3 class="text-xl font-bold text-gray-800 mt-0">How to Check for Balanced Brackets</h3>
            <p>Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if open brackets are closed by the same type of brackets and in the correct order.</p>
            <p><strong>Example:</strong> <code>"()[]{}"</code> is valid, but <code>"([)]"</code> is not.</p>
            <p><strong>Approach:</strong> Use a stack. When you see an opening bracket, push it onto the stack. When you see a closing bracket, check if the stack is empty or if the top element is the corresponding opening bracket. If it is, pop the stack. If not, the string is invalid. After iterating through the string, if the stack is empty, the string is valid.</p>
            <button class="interactive-button" onclick="toggleCode('valid-paren')">Show Code</button>
            <pre id="valid-paren" style="display:none;"><code class="language-java">import java.util.Stack;

class ValidParentheses {
    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) {
                    return false; // Closing bracket with no opening
                }
                char top = stack.pop();
                if ((c == ')' && top != '(') ||
                    (c == '}' && top != '{') ||
                    (c == ']' && top != '[')) {
                    return false; // Mismatched brackets
                }
            }
        }
        return stack.isEmpty(); // Must be empty for a valid string
    }
}</code></pre>
             <button class="interactive-button" onclick="dryRunValidParen()">Dry Run</button>
            <div id="valid-paren-dry-run" class="dry-run-output" style="display:none;"></div>
        </div>

        <!-- Reverse Polish Notation -->
        <h2 class="text-3xl font-bold text-gray-800">6. Dealing with Reverse Polish Notation (RPN)</h2>
        <div class="example-box border-l-red-500">
            <h3 class="text-xl font-bold text-gray-800 mt-0">Evaluating RPN Expressions</h3>
            <p>Reverse Polish Notation is a mathematical notation in which every operator follows all of its operands. For example, to add 3 and 4, one would write <code>"3 4 +"</code> instead of <code>"3 + 4"</code>.</p>
            <p><strong>Approach:</strong> Use a stack. Iterate through the tokens. If a token is a number, push it onto the stack. If it's an operator, pop the top two numbers from the stack, perform the operation, and push the result back onto the stack. The final result is the last number remaining in the stack.</p>
            <button class="interactive-button" onclick="toggleCode('rpn-eval')">Show Code</button>
            <pre id="rpn-eval" style="display:none;"><code class="language-java">import java.util.Stack;

class RPN {
    public int evalRPN(String[] tokens) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        for (String token : tokens) {
            if (token.equals("+")) {
                stack.push(stack.pop() + stack.pop());
            } else if (token.equals("-")) {
                int b = stack.pop();
                int a = stack.pop();
                stack.push(a - b);
            } else if (token.equals("*")) {
                stack.push(stack.pop() * stack.pop());
            } else if (token.equals("/")) {
                int b = stack.pop();
                int a = stack.pop();
                stack.push(a / b);
            } else {
                stack.push(Integer.parseInt(token));
            }
        }
        return stack.pop();
    }
}</code></pre>
        </div>
        
        <!-- Monotonic Stack Introduction -->
        <h2 class="text-3xl font-bold text-gray-800">7. Introduction to Monotonic Stacks</h2>
        <div class="example-box border-l-pink-500">
            <h3 class="text-xl font-bold text-gray-800 mt-0">A Powerful Stack Variant</h3>
            <p>A <strong>monotonic stack</strong> is a special type of stack where the elements are always in a sorted order, either non-increasing or non-decreasing. This property makes them extremely useful for problems where we need to find the "next" or "previous" element that has a certain property (e.g., is greater than, or less than, the current element).</p>
            <ul>
                <li>A <strong>monotonically increasing</strong> stack keeps elements in ascending order from bottom to top. When pushing a new element, we pop all elements from the top that are greater than or equal to the new element to maintain the property.</li>
                <li>A <strong>monotonically decreasing</strong> stack keeps elements in descending order. When pushing a new element, we pop all elements from the top that are smaller than or equal to the new element.</li>
            </ul>
             <p>This pattern allows us to process each element in an array and efficiently find its nearest neighbors that satisfy a condition, often achieving an O(n) time complexity for the overall algorithm.</p>
             <h3 class="text-xl font-bold text-gray-800 mt-4">Example: Finding Previous Less Element</h3>
             <p>Here's a concrete example of a monotonically increasing stack used to find the previous element that is strictly smaller than the current one.</p>
             <button class="interactive-button" onclick="toggleCode('monotonic-increasing-code')">Show Code</button>
             <pre id="monotonic-increasing-code" style="display:none;"><code class="language-java">import java.util.Stack;
import java.util.Arrays;

class PreviousLessElement {
    public int[] findPLE(int[] arr) {
        int n = arr.length;
        int[] ple = new int[n];
        // Stack will store elements in increasing order
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

        // Iterate from left to right
        for (int i = 0; i < n; i++) {
            // While stack is not empty and top is greater than or equal to current element
            while (!stack.isEmpty() && stack.peek() >= arr[i]) {
                stack.pop();
            }

            // If stack is empty, no smaller element on the left
            if (stack.isEmpty()) {
                ple[i] = -1;
            } else {
                // Top of the stack is the previous less element
                ple[i] = stack.peek();
            }

            // Push current element to the stack
            stack.push(arr[i]);
        }
        return ple;
    }
}

// Example:
// int[] arr = {4, 2, 5, 1, 3};
// PreviousLessElement pleFinder = new PreviousLessElement();
// int[] result = pleFinder.findPLE(arr);
// System.out.println(Arrays.toString(result)); // Output: [-1, -1, 2, -1, 1]
</code></pre>
            <button class="interactive-button" onclick="dryRunMonotonicIncreasing()">Dry Run</button>
            <div id="monotonic-increasing-dry-run" class="dry-run-output" style="display:none;"></div>
        </div>


        <!-- Next Greater Element (NGE) with Stack -->
        <h2 class="text-3xl font-bold text-gray-800">8. Problem: Next Greater Element (Efficiently)</h2>
        <div class="example-box border-l-teal-500">
            <h3 class="text-xl font-bold text-gray-800 mt-0">An O(n) Solution using a Monotonic Stack</h3>
            <p>This problem is a classic application of a monotonic stack. The goal is to find the first element on the right side of an array element that is greater than it.
            </p>
            <p><strong>Approach:</strong> We will use a <strong>monotonically decreasing stack</strong>. We iterate through the array from right to left. For each element, we pop elements from the stack that are less than or equal to the current element. This ensures that when we stop, the stack's top is the first element to the right that is greater. If the stack is empty after popping, it means no such element exists.</p>
             <div><span class="complexity-tag">Time: O(n)</span><span class="complexity-tag">Space: O(n)</span></div>
            <button class="interactive-button" onclick="toggleCode('nge-stack')">Show Code</button>
            <pre id="nge-stack" style="display:none;"><code class="language-java">import java.util.Stack;
import java.util.Arrays;

class NextGreaterElement {
    public int[] findNGE(int[] arr) {
        int n = arr.length;
        int[] nge = new int[n];
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

        // Iterate from right to left
        for (int i = n - 1; i >= 0; i--) {
            // Maintain a monotonically decreasing stack
            while (!stack.isEmpty() && stack.peek() <= arr[i]) {
                stack.pop();
            }

            // If stack is empty, no greater element on the right
            if (stack.isEmpty()) {
                nge[i] = -1;
            } else {
                // Top of the stack is the NGE
                nge[i] = stack.peek();
            }

            // Push current element to the stack
            stack.push(arr[i]);
        }
        return nge;
    }
}

// Example:
// int[] arr = {4, 5, 2, 25};
// NextGreaterElement ngeFinder = new NextGreaterElement();
// int[] result = ngeFinder.findNGE(arr);
// System.out.println(Arrays.toString(result)); // Output: [5, 25, 25, -1]
</code></pre>
            <button class="interactive-button" onclick="dryRunNGE()">Dry Run</button>
            <div id="nge-dry-run" class="dry-run-output" style="display:none;"></div>
        </div>

        <!-- Largest Rectangle in Histogram -->
        <h2 class="text-3xl font-bold text-gray-800">9. Problem: Largest Rectangle in Histogram</h2>
        <div class="example-box border-l-yellow-500">
            <h3 class="text-xl font-bold text-gray-800 mt-0">Using a Monotonic Stack for Optimal Area</h3>
            <p>Given an array of integers <code>heights</code> representing the histogram's bar height where the width of each bar is 1, find the area of the largest rectangle in the histogram.</p>
            <p><strong>Example:</strong> For <code>heights = [2,1,5,6,2,3]</code>, the largest rectangle has an area of 10.</p>
            <p><strong>Approach:</strong> For each bar, the largest rectangle using that bar's height is bounded by the first shorter bar to its left (Previous Less Element) and the first shorter bar to its right (Next Less Element). We can find these boundaries efficiently using a <strong>monotonically increasing stack</strong>, where we store indices of the bars.</p>
            <p>We iterate through the bars. If the current bar is shorter than the bar at the stack's top, it means the current bar is the "Next Less Element" for the bar at the top. We can then pop the top bar, calculate its potential area, and update our maximum area. The "Previous Less Element" for the popped bar is the new top of the stack.</p>
             <div><span class="complexity-tag">Time: O(n)</span><span class="complexity-tag">Space: O(n)</span></div>
            <button class="interactive-button" onclick="toggleCode('histogram-code')">Show Code</button>
            <pre id="histogram-code" style="display:none;"><code class="language-java">import java.util.Stack;

class LargestRectangleHistogram {
    public int largestRectangleArea(int[] heights) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int maxArea = 0;
        int n = heights.length;

        for (int i = 0; i <= n; i++) {
            // Use a virtual bar of height 0 at the end to process remaining bars
            int h = (i == n) ? 0 : heights[i];
            
            // Maintain a monotonically increasing stack of indices
            while (!stack.isEmpty() && h < heights[stack.peek()]) {
                int height = heights[stack.pop()];
                // Left boundary is the new stack top, right boundary is current index i
                int width = stack.isEmpty() ? i : i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }
            // Push current index onto the stack
            stack.push(i);
        }
        
        return maxArea;
    }
}</code></pre>
            <button class="interactive-button" onclick="dryRunHistogram()">Dry Run</button>
            <div id="histogram-dry-run" class="dry-run-output" style="display:none;"></div>
        </div>

    </div>
</main>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script>
    function toggleCode(id) {
        const element = document.getElementById(id);
        if (element.style.display === 'none') {
            element.style.display = 'block';
            Prism.highlightAllUnder(element);
        } else {
            element.style.display = 'none';
        }
    }

    function dryRunStack() {
        const outputEl = document.getElementById('stack-dry-run');
        outputEl.style.display = 'block';
        let output = '--- Initializing Stack of size 3 ---\n';
        output += 'MyStack stack = new MyStack(3);\n';
        output += 'top = -1, capacity = 3\n\n';
        
        output += '--- Pushing 10 ---\n';
        output += 'isFull() is false. top becomes 0. arr[0] = 10.\n';
        output += 'Stack: [10], top = 0\n\n';

        output += '--- Pushing 20 ---\n';
        output += 'isFull() is false. top becomes 1. arr[1] = 20.\n';
        output += 'Stack: [10, 20], top = 1\n\n';
        
        output += '--- Pushing 30 ---\n';
        output += 'isFull() is false. top becomes 2. arr[2] = 30.\n';
        output += 'Stack: [10, 20, 30], top = 2\n\n';

        output += '--- Pushing 40 ---\n';
        output += 'isFull() is true. Prints "Overflow!".\n\n';

        output += '--- Popping ---\n';
        output += 'isEmpty() is false. Returns arr[2] (30). top becomes 1.\n';
        output += 'Stack: [10, 20], top = 1\n\n';

        output += '--- Peeking ---\n';
        output += 'isEmpty() is false. Returns arr[1] (20). top remains 1.\n';
        output += 'Stack: [10, 20], top = 1\n';

        outputEl.textContent = output;
    }
    
    function dryRunValidParen() {
        const outputEl = document.getElementById('valid-paren-dry-run');
        outputEl.style.display = 'block';
        let output = '--- Dry Run for isValid("([{}])") ---\n\n';
        output += 'String: ([{}])\n\n';
        
        output += '1. Read \'(\': It\'s an opening bracket. Push to stack.\n';
        output += '   Stack: [(\n\n';
        
        output += '2. Read \'[\': It\'s an opening bracket. Push to stack.\n';
        output += '   Stack: [ (, [\n\n';
        
        output += '3. Read \'{\': It\'s an opening bracket. Push to stack.\n';
        output += '   Stack: [ (, [, {\n\n';
        
        output += '4. Read \'}\': It\'s a closing bracket. Pop from stack.\n';
        output += '   Popped \'{\'. Matches \'}\'. Continue.\n';
        output += '   Stack: [ (, [\n\n';
        
        output += '5. Read \']\': It\'s a closing bracket. Pop from stack.\n';
        output += '   Popped \'[\'. Matches \']\'. Continue.\n';
        output += '   Stack: [ (\n\n';

        output += '6. Read \')\': It\'s a closing bracket. Pop from stack.\n';
        output += '   Popped \'(\'. Matches \')\'. Continue.\n';
        output += '   Stack: [] (empty)\n\n';
        
        output += 'End of string. Stack is empty. Result: true (Valid)\n';

        outputEl.textContent = output;
    }

    function dryRunNGE() {
        const outputEl = document.getElementById('nge-dry-run');
        outputEl.style.display = 'block';
        let output = '--- Dry Run for findNGE({4, 5, 2, 25}) ---\n\n';
        output += 'Array: [4, 5, 2, 25]\n';
        output += 'Result Array (nge): [?, ?, ?, ?]\n';
        output += 'Stack: [] (empty)\n\n';

        output += '--- i = 3 (arr[3] = 25) ---\n';
        output += 'Stack is empty. Pop loop is skipped.\n';
        output += 'nge[3] = -1.\n';
        output += 'Push 25 to stack.\n';
        output += 'nge: [?, ?, ?, -1], Stack: [25]\n\n';

        output += '--- i = 2 (arr[2] = 2) ---\n';
        output += 'Stack top (25) > 2. Pop loop is skipped.\n';
        output += 'nge[2] = stack.peek() which is 25.\n';
        output += 'Push 2 to stack.\n';
        output += 'nge: [?, ?, 25, -1], Stack: [25, 2]\n\n';

        output += '--- i = 1 (arr[1] = 5) ---\n';
        output += 'Stack top (2) <= 5. Pop 2.\n';
        output += 'Stack: [25]\n';
        output += 'Stack top (25) > 5. Pop loop ends.\n';
        output += 'nge[1] = stack.peek() which is 25.\n';
        output += 'Push 5 to stack.\n';
        output += 'nge: [?, 25, 25, -1], Stack: [25, 5]\n\n';

        output += '--- i = 0 (arr[0] = 4) ---\n';
        output += 'Stack top (5) > 4. Pop loop is skipped.\n';
        output += 'nge[0] = stack.peek() which is 5.\n';
        output += 'Push 4 to stack.\n';
        output += 'nge: [5, 25, 25, -1], Stack: [25, 5, 4]\n\n';

        output += '--- Final Result ---\n';
        output += 'nge: [5, 25, 25, -1]\n';

        outputEl.textContent = output;
    }
    
    function dryRunMonotonicIncreasing() {
        const outputEl = document.getElementById('monotonic-increasing-dry-run');
        outputEl.style.display = 'block';
        let output = '--- Dry Run for findPLE({4, 2, 5, 1, 3}) ---\n\n';
        output += 'Array: [4, 2, 5, 1, 3]\n';
        output += 'Result Array (ple): [?, ?, ?, ?, ?]\n';
        output += 'Stack: [] (empty)\n\n';

        output += '--- i = 0 (arr[0] = 4) ---\n';
        output += 'Stack is empty. Pop loop is skipped.\n';
        output += 'ple[0] = -1.\n';
        output += 'Push 4 to stack.\n';
        output += 'ple: [-1, ?, ?, ?, ?], Stack: [4]\n\n';

        output += '--- i = 1 (arr[1] = 2) ---\n';
        output += 'Stack top (4) >= 2. Pop 4.\n';
        output += 'Stack is now empty. Pop loop ends.\n';
        output += 'ple[1] = -1.\n';
        output += 'Push 2 to stack.\n';
        output += 'ple: [-1, -1, ?, ?, ?], Stack: [2]\n\n';

        output += '--- i = 2 (arr[2] = 5) ---\n';
        output += 'Stack top (2) < 5. Pop loop is skipped.\n';
        output += 'ple[2] = stack.peek() which is 2.\n';
        output += 'Push 5 to stack.\n';
        output += 'ple: [-1, -1, 2, ?, ?], Stack: [2, 5]\n\n';

        output += '--- i = 3 (arr[3] = 1) ---\n';
        output += 'Stack top (5) >= 1. Pop 5.\n';
        output += 'Stack: [2]\n';
        output += 'Stack top (2) >= 1. Pop 2.\n';
        output += 'Stack is now empty. Pop loop ends.\n';
        output += 'ple[3] = -1.\n';
        output += 'Push 1 to stack.\n';
        output += 'ple: [-1, -1, 2, -1, ?], Stack: [1]\n\n';

        output += '--- i = 4 (arr[4] = 3) ---\n';
        output += 'Stack top (1) < 3. Pop loop is skipped.\n';
        output += 'ple[4] = stack.peek() which is 1.\n';
        output += 'Push 3 to stack.\n';
        output += 'ple: [-1, -1, 2, -1, 1], Stack: [1, 3]\n\n';

        output += '--- Final Result ---\n';
        output += 'ple: [-1, -1, 2, -1, 1]\n';

        outputEl.textContent = output;
    }

    function dryRunHistogram() {
        const outputEl = document.getElementById('histogram-dry-run');
        outputEl.style.display = 'block';
        let output = '--- Dry Run for largestRectangleArea({2, 1, 5, 6, 2, 3}) ---\n\n';
        output += 'Heights: [2, 1, 5, 6, 2, 3]\n';
        output += 'maxArea = 0, Stack: [] (stores indices)\n\n';

        output += 'i = 0, h = 2: Stack empty or h >= top. Push 0. Stack: [0]\n';
        output += 'i = 1, h = 1: h < heights[0](2). WHILE loop starts.\n';
        output += '  - Pop 0. height=2. width=1. area=2. maxArea=2.\n';
        output += '  - Stack is now empty. Loop ends. Push 1. Stack: [1]\n\n';

        output += 'i = 2, h = 5: h > heights[1](1). Push 2. Stack: [1, 2]\n';
        output += 'i = 3, h = 6: h > heights[2](5). Push 3. Stack: [1, 2, 3]\n';
        output += 'i = 4, h = 2: h < heights[3](6). WHILE loop starts.\n';
        output += '  - Pop 3. height=6. width=4-2-1=1. area=6. maxArea=6.\n';
        output += '  - Stack: [1, 2]. h < heights[2](5). Loop continues.\n';
        output += '  - Pop 2. height=5. width=4-1-1=2. area=10. maxArea=10.\n';
        output += '  - Stack: [1]. h > heights[1](1). Loop ends. Push 4. Stack: [1, 4]\n\n';
        
        output += 'i = 5, h = 3: h > heights[4](2). Push 5. Stack: [1, 4, 5]\n\n';

        output += 'i = 6, h = 0 (virtual bar): h < heights[5](3). WHILE loop starts.\n';
        output += '  - Pop 5. height=3. width=6-4-1=1. area=3. maxArea=10.\n';
        output += '  - Stack: [1, 4]. h < heights[4](2). Loop continues.\n';
        output += '  - Pop 4. height=2. width=6-1-1=4. area=8. maxArea=10.\n';
        output += '  - Stack: [1]. h < heights[1](1). Loop continues.\n';
        output += '  - Pop 1. height=1. width=6. area=6. maxArea=10.\n';
        output += '  - Stack is empty. Loop ends. Push 6. Stack: [6]\n\n';
        
        output += 'Loop ends. Final maxArea = 10\n';

        outputEl.textContent = output;
    }
</script>
</body>
</html>
