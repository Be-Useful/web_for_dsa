<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Class 2: Structural Recursion & Pre-processing</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Prism.js for code highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        /* Reusing the exact same styles from tree.html for consistency */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f3f4f6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .content-area {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 2rem;
            box-sizing: border-box;
        }

        .presentation-card {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            padding: 2.5rem;
            width: 90%;
            max-width: 960px;
            box-sizing: border-box;
        }

        .presentation-card h1, .presentation-card h2 {
            color: #1f2937;
            margin-bottom: 1.5rem;
            font-weight: 800;
        }
        
        .presentation-card h3 {
             color: #1f2937;
             font-weight: 700;
             margin-top: 1.5rem;
             margin-bottom: 1rem;
        }

        .presentation-card p, .presentation-card li {
            color: #4b5563;
            line-height: 1.7;
            margin-bottom: 1rem;
            font-size: 1.05rem;
        }
        
        .presentation-card code:not(pre > code) {
            background-color: #eef2ff;
            color: #4338ca;
            padding: 0.2rem 0.5rem;
            border-radius: 0.375rem;
            font-family: 'Courier New', Courier, monospace;
            font-weight: 600;
        }
        
        .presentation-card pre {
            border-radius: 0.5rem;
            margin-top: 1rem;
            background-color: #2d2d2d; /* Matching prism-tomorrow */
            color: #e5e7eb; /* Light text for dark background */
            padding: 1.5rem;
            overflow-x: auto;
        }

        .presentation-card .example-box {
            background-color: #f9fafb;
            border-left-width: 4px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            margin-bottom: 2.5rem;
            border-radius: 0.5rem;
        }
        
        .code-toggle-button {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            display: inline-block;
            margin-top: 1rem;
        }
        .code-toggle-button:hover {
            background-color: #4338ca;
        }
        
        .hidden-code {
            display: none;
        }

        .navbar {
            background-color: #4338ca;
            padding: 1rem 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .navbar a {
            color: white;
            text-decoration: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
        }

        .navbar a:hover {
            background-color: #4f46e5;
            transform: translateY(-2px);
        }

        .navbar a.active-nav {
            background-color: #6d28d9;
            font-weight: 700;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        @media (max-width: 768px) {
            .presentation-card { padding: 1.5rem; width: 95%; }
            .presentation-card h1 { font-size: 2.2rem; }
            .presentation-card h2 { font-size: 1.8rem; }
            .navbar { justify-content: flex-start; overflow-x: auto; }
        }
    </style>
</head>
<body>
    <!-- Navigation Bar (can be populated by a script) -->
    <nav class="navbar">
        <!-- Navigation links will be inserted here by update_nav.js -->
    </nav>
    
    <!-- Include the navigation update script -->
    <script src="update_nav.js"></script>
    
    <!-- Include the navigation update script -->
    <script src="update_nav.js"></script>
    
    <!-- Main Content Area -->
    <main class="content-area">
        <div class="presentation-card">
            <div class="text-center mb-8">
                <h1 class="text-4xl lg:text-5xl font-extrabold text-indigo-700 mb-4">Class 2: Structural Recursion & Pre-processing</h1>
                <p class="text-lg text-gray-600">Deepening your recursive thinking on trees.</p>
            </div>

            <hr class="my-12 border-t-2 border-gray-200">

            <h2 class="text-3xl font-bold text-gray-800">ðŸ“š Core Structural Problems</h2>
            <p>Let's start with problems where the recursion directly mirrors the tree's structure. The key is to ask: "What can my children's answers tell me about my own answer?"</p>

            <!-- Problem 1: Identical Trees -->
            <div class="example-box border-l-green-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">1. Check if Two Trees are Identical</h3>
                <p><strong>Goal:</strong> Given two binary trees, <code>p</code> and <code>q</code>, check if they are the same. "Same" means they have the same structure and the same node values.</p>
                <p><strong>Intuition & Recursive Breakdown:</strong>
                    Two trees are identical if:
                    <ul class="list-disc list-inside">
                        <li>Their root nodes have the same value.</li>
                        <li>The left subtree of the first tree is identical to the left subtree of the second.</li>
                        <li>The right subtree of the first tree is identical to the right subtree of the second.</li>
                    </ul>
                    <strong>Base Cases:</strong> If both nodes are <code>null</code>, they are identical. If one is <code>null</code> and the other isn't, they are not.
                </p>
                <button class="code-toggle-button">Show Java Code</button>
                <pre class="hidden-code"><code class="language-java">
// Definition for a binary tree node.
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

class Solution {
    // This function uses pure recursion without any global state.
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // Base Case 1: If both nodes are null, they are identical.
        if (p == null && q == null) {
            return true;
        }
        // Base Case 2: If one is null or values don't match, they are not identical.
        if (p == null || q == null || p.val != q.val) {
            return false;
        }
        
        // Recursive Step: Check if left and right subtrees are also identical.
        boolean isLeftSame = isSameTree(p.left, q.left);
        boolean isRightSame = isSameTree(p.right, q.right);
        
        return isLeftSame && isRightSame;
    }
}
                </code></pre>
                <p class="mt-4"><strong>Practice Link:</strong> <a href="https://leetcode.com/problems/same-tree/" class="text-indigo-600 hover:underline">LeetCode 100. Same Tree</a></p>
            </div>

            <!-- Problem 2: Height of a Binary Tree -->
            <div class="example-box border-l-blue-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">2. Find the Height of a Binary Tree</h3>
                <p><strong>Goal:</strong> Find the number of edges on the longest path from the root to a leaf.</p>
                <p><strong>Intuition & Recursive Breakdown:</strong> The height of a tree rooted at <code>node</code> is <code>1</code> plus the maximum height of its left and right subtrees.
                    <br><strong>Base Case:</strong> A <code>null</code> node represents an empty tree. We define its height as -1, so a single-node tree has a height of <code>1 + max(-1, -1) = 0</code>.
                </p>
                <button class="code-toggle-button">Show Java Code</button>
                <pre class="hidden-code"><code class="language-java">
class Solution {
    // This is a classic postorder traversal pattern. We compute children's
    // results first, then combine them at the parent.
    public int maxDepth(TreeNode root) {
        // Base Case: An empty tree has a height of -1 (or depth 0).
        // LeetCode defines depth, so we return 0 for a null root.
        // Let's stick to the height definition for clarity here.
        if (root == null) {
            return -1; 
        }
        
        // Recursive Step: Get height of left and right subtrees.
        int leftHeight = maxDepth(root.left);
        int rightHeight = maxDepth(root.right);
        
        // The height of the current node is 1 + the max of its subtrees.
        return 1 + Math.max(leftHeight, rightHeight);
    }
}
                </code></pre>
                 <p class="mt-4"><strong>Practice Link:</strong> <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" class="text-indigo-600 hover:underline">LeetCode 104. Maximum Depth of Binary Tree</a></p>
            </div>
            
            <hr class="my-12 border-t-2 border-gray-200">

            <h2 class="text-3xl font-bold text-gray-800">ðŸ§  Pre-processing & Optimized Recursion</h2>
            <p>Now, let's look at problems where a simple traversal isn't enough. We need to compute information in a specific order (usually postorder) to solve the problem efficiently in a single pass.</p>

            <!-- Problem 3: Balanced Binary Tree -->
            <div class="example-box border-l-purple-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">3. Check if a Tree is Balanced</h3>
                <p><strong>Goal:</strong> A binary tree is "height-balanced" if for every node, the difference between the heights of its left and right subtrees is at most 1.</p>
                <p><strong>Intuition & Recursive Breakdown:</strong> To check if a node is balanced, we need the height of its subtrees. We can do this in a postorder way: first, get the heights from the children. Then, at the parent, check the balance condition. If it's unbalanced at any point, we need to stop and propagate that "unbalanced" signal up.
                <br>We can use a special return value (like -1) to signal that an unbalance was found below.</p>
                <button class="code-toggle-button">Show Java Code</button>
                <pre class="hidden-code"><code class="language-java">
class Solution {
    // We return the height if balanced, or -1 if unbalanced.
    // This avoids re-calculating height at every node.
    private int checkHeight(TreeNode root) {
        if (root == null) {
            return 0; // Height of a null tree is 0
        }

        // Postorder: Recurse left and right first.
        int leftHeight = checkHeight(root.left);
        if (leftHeight == -1) return -1; // Propagate unbalance signal

        int rightHeight = checkHeight(root.right);
        if (rightHeight == -1) return -1; // Propagate unbalance signal

        // Check the balance condition at the current node.
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1; // Found an unbalance
        }

        // Return the actual height if balanced.
        return 1 + Math.max(leftHeight, rightHeight);
    }

    public boolean isBalanced(TreeNode root) {
        return checkHeight(root) != -1;
    }
}
                </code></pre>
                 <p class="mt-4"><strong>Practice Link:</strong> <a href="https://leetcode.com/problems/balanced-binary-tree/" class="text-indigo-600 hover:underline">LeetCode 110. Balanced Binary Tree</a></p>
            </div>

            <!-- Problem 4: Diameter of a Binary Tree -->
            <div class="example-box border-l-red-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">4. Diameter of a Binary Tree</h3>
                <p><strong>Goal:</strong> Find the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>
                <p><strong>Intuition & Recursive Breakdown:</strong> For any node, the longest path (diameter) that involves this node is <code>height(left) + height(right) + 2</code>. However, the overall diameter might be entirely within the left subtree or entirely within the right subtree.
                <br>So, our recursion needs to do two things:
                <ol class="list-decimal list-inside">
                    <li>Calculate the height of the current node's subtree.</li>
                    <li>Update a global maximum diameter found so far.</li>
                </ol>
                </p>
                <button class="code-toggle-button">Show Java Code</button>
                <pre class="hidden-code"><code class="language-java">
class Solution {
    // Using a global variable (or a single-element array/object) to track the max diameter.
    private int maxDiameter = 0;

    // The function returns the height of the tree rooted at 'node'.
    // While doing so, it updates the global maxDiameter.
    private int heightAndUpdateDiameter(TreeNode node) {
        if (node == null) {
            return -1;
        }

        // Postorder: get heights from children first.
        int leftHeight = heightAndUpdateDiameter(node.left);
        int rightHeight = heightAndUpdateDiameter(node.right);

        // The potential diameter passing through the current node.
        // The path length is the number of edges, so leftHeight + rightHeight + 2.
        int currentDiameter = leftHeight + rightHeight + 2;
        
        // Update the overall maximum diameter found.
        maxDiameter = Math.max(maxDiameter, currentDiameter);

        // Return the height for the parent node's calculation.
        return 1 + Math.max(leftHeight, rightHeight);
    }

    public int diameterOfBinaryTree(TreeNode root) {
        heightAndUpdateDiameter(root);
        return maxDiameter;
    }
}
                </code></pre>
                 <p class="mt-4"><strong>Practice Link:</strong> <a href="https://leetcode.com/problems/diameter-of-binary-tree/" class="text-indigo-600 hover:underline">LeetCode 543. Diameter of Binary Tree</a></p>
            </div>
            
            <hr class="my-12 border-t-2 border-gray-200">

            <h2 class="text-3xl font-bold text-gray-800">âœ¨ Enrichment: Accumulating Metrics in One Pass</h2>
            <p>A powerful pattern is to return multiple pieces of information from your recursive calls. This lets you compute several properties of a tree in a single DFS traversal, which is very efficient.</p>

            <!-- Enrichment Problem -->
            <div class="example-box border-l-yellow-500">
                <h3 class="text-xl font-bold text-gray-800 mt-0">Count Nodes, Sum Values, and Count Leaves Together</h3>
                <p><strong>Goal:</strong> In a single traversal, calculate the total number of nodes, the sum of all node values, and the total number of leaf nodes.</p>
                <p><strong>Intuition & Recursive Breakdown:</strong> We can define a helper class or use an array (e.g., <code>int[]</code>) to hold multiple return values. Let's use an array <code>[nodeCount, valueSum, leafCount]</code>.
                <br>In a postorder traversal:
                <ol class="list-decimal list-inside">
                    <li>Get the metrics array from the left child.</li>
                    <li>Get the metrics array from the right child.</li>
                    <li>Combine them: your count is <code>1 + left[0] + right[0]</code>, your sum is <code>node.val + left[1] + right[1]</code>, and so on.</li>
                </ol>
                <strong>Base Case:</strong> A <code>null</code> node returns <code>[0, 0, 0]</code>. A leaf node returns <code>[1, node.val, 1]</code>.
                </p>
                <button class="code-toggle-button">Show Java Code</button>
                <pre class="hidden-code"><code class="language-java">
class Solution {
    // We return an array: [nodeCount, valueSum, leafCount]
    public int[] getTreeMetrics(TreeNode node) {
        if (node == null) {
            return new int[]{0, 0, 0};
        }

        // Base Case: Leaf Node
        if (node.left == null && node.right == null) {
            return new int[]{1, node.val, 1};
        }

        // Postorder Traversal
        int[] leftMetrics = getTreeMetrics(node.left);
        int[] rightMetrics = getTreeMetrics(node.right);

        // Combine results
        int totalNodes = 1 + leftMetrics[0] + rightMetrics[0];
        int totalSum = node.val + leftMetrics[1] + rightMetrics[1];
        int totalLeaves = leftMetrics[2] + rightMetrics[2];

        return new int[]{totalNodes, totalSum, totalLeaves};
    }

    public void analyzeTree(TreeNode root) {
        int[] metrics = getTreeMetrics(root);
        System.out.println("Total Nodes: " + metrics[0]);
        System.out.println("Sum of Values: " + metrics[1]);
        System.out.println("Leaf Nodes: " + metrics[2]);
    }
}
                </code></pre>
                 <p class="mt-4"><strong>Practice Links:</strong> This pattern combines ideas from several problems.
                    <br><a href="https://practice.geeksforgeeks.org/problems/sum-of-binary-tree/1" class="text-indigo-600 hover:underline">GfG: Sum of Binary Tree</a>
                    <br><a href="https://practice.geeksforgeeks.org/problems/count-leaves-in-binary-tree/1" class="text-indigo-600 hover:underline">GfG: Count Leaves in Binary Tree</a>
                 </p>
            </div>

        </div>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // JavaScript to handle the "Show/Hide Code" functionality
        document.addEventListener('DOMContentLoaded', () => {
            const buttons = document.querySelectorAll('.code-toggle-button');
            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    const codeBlock = button.nextElementSibling;
                    if (codeBlock.classList.contains('hidden-code')) {
                        codeBlock.classList.remove('hidden-code');
                        button.textContent = 'Hide Code';
                        // Trigger Prism to highlight the newly visible block
                        Prism.highlightElement(codeBlock.querySelector('code'));
                    } else {
                        codeBlock.classList.add('hidden-code');
                        button.textContent = 'Show Code';
                    }
                });
            });
        });
    </script>
</body>
</html>
